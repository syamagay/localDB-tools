#!/usr/bin/env python3
#################################
# Author: Arisa Kubota
# Email: arisa.kubota at cern.ch
# Date: July 2019
# Project: Local Database for YARR
#################################

# Common
import os
import sys
import shutil
import requests
import json
import signal

import argparse 

from getpass    import getpass
from pymongo    import MongoClient, errors, DESCENDING
from datetime   import datetime

sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)),'../lib/localdb-tools/modules'))

import register

DB_DEBUG=False

def readConfig(conf_path):
    f = open(conf_path, 'r')
    conf = json.load(f)
    return conf

def getArgs():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--config', help='Set config file path.', type=str)
    parser.add_argument('--host', help='Set the Local DB Server Host.', type=str)
    parser.add_argument('--port', help='Set the Local DB Server Port.', type=str)
    parser.add_argument('--username', help='Set the User Name of Local DB Server.', type=str)
    parser.add_argument('--password', help='Set the Password of Local DB Server.', type=str)
    parser.add_argument('--database', help='Set the Local DB Name.', type=str, default='localdb')
    args = parser.parse_args()

    if args.config is not None:
        conf = readConfig(args.config)    # Read from config file
        if 'hostIp'   in conf and not args.host:     args.host     = conf['hostIp']
        if 'hostPort' in conf and not args.port:     args.port     = conf['hostPort']
        if 'dbName'   in conf and not args.database: args.database = conf['dbName']
    return args

def getTestRunData(tr_oid, serial_number, timestamp):
    if DB_DEBUG: print('Local DB: Get TestRun Data')

    global localdb

    global m_tr_oid
    m_tr_oid = '';

    if tr_oid=='' and (serial_number=='' or timestamp==-1):
        #TODO alert
        return

    if tr_oid=='':
        start_time = datetime.utcfromtimestamp(timestamp)
        doc_value = {
            'startTime': start_time,
            'serialNumber': serial_number
        }
    else:
        doc_value = {
            '_id': ObjectId(tr_oid)
        }
    this_run = localdb.testRun.find_one(doc_value)
    if this_run: m_tr_oid = this_run['_id']

def __init(url, name):
    global args
    global localdb

    max_server_delay = 1
    client = MongoClient(url, serverSelectionTimeoutMS=max_server_delay)
    try:
        client.server_info()
    except errors.ServerSelectionTimeoutError as err:
        #print('WARNING: The connection of Local DB {} is BAD.'.format(url))
        #print('         {}\n'.format(err))
        return False
    except errors.OperationFailure as err:
        db = client[name]
        try:
            db.authenticate(args.username, args.password)
        except errors.OperationFailure as err: 
            #print('ERROR: Authentication failed.')
            return False

    localdb = client[name]
    register.__set_localdb(localdb)
    localdb['fs.files'].create_index([('hash', DESCENDING), ('_id', DESCENDING)])

    conf = readConfig(args.config)
    register.__set_stage_list(conf['stage'])
    register.__set_env_list(conf['environment'])
    register.__set_cmp_list(conf['component'])

    global m_cache_dir
    m_cache_dir = conf["cachePath"];

    #else m_log_dir = m_cache_dir+"/tmp/log";//TODO
    #m_log_path = m_log_dir + "/cacheLog.json";
    #this->mkdir(m_log_dir);
    #m_log_json["version"] = m_db_version;
    #m_log_json["logPath"] = m_log_dir;
    #m_log_json["dbOption"] = m_option;
    #this->writeJson("status", "running", m_log_path, m_log_json);
    #this->cacheDBCfg(); 

    return True

def __set_cache(cache_dir):
    if DB_DEBUG: print('Local DB: Write cache data: {}'.format(cache_dir))

    global m_cache_path
    global m_cache_json

    m_cache_path = cache_dir+'/cacheLog.json'
    m_cache_json = register.toJson(m_cache_path)
    option = m_cache_json.get('dbOption', 'null')

    register.__global.m_db_version = m_cache_json['version']

    if option=='scan': __write_scan(cache_dir)
    if option=='dcs': __write_dcs(cache_dir)

def __write_scan(cache_dir):
    if DB_DEBUG: print('Local DB: Write cache scan data: {}'.format(cache_dir))

    global m_cache_json
    global m_cache_dir

    now = datetime.now().timestamp()
    if m_cache_json['status']=='done':
        shutil.move(cache_dir, '{0}/tmp/localdb/done/{1}'.format(m_cache_dir, now))
        return
    elif m_cache_json['status']=='failure':
        shutil.move(cache_dir, '{0}/tmp/localdb/failed/{1}'.format(m_cache_dir, now))
        return
    if m_cache_json['status']!='waiting': return
    #register.writeJson('status', 'writing', m_cache_path, m_cache_json); #TODO MUST BE REMOVE COMMENT OUT

    register.__set_user('{}/user.json'.format(cache_dir))

    register.__set_site('{}/address.json'.format(cache_dir))

#TODO
    timestamp = m_cache_json["startTime"]
    conn_paths = []
    for conn_cfg in m_cache_json["configs"]["connCfg"]:
        conn_path = cache_dir+'/'+conn_cfg['path']
        conn_json = register.toJson(conn_path)
        mo_serial_number = conn_json["module"]["serialNumber"]
        getTestRunData('', mo_serial_number, timestamp)
        global m_tr_oid
        if m_tr_oid!='':
            message = 'Already registered test run data in DB, then skip to save...'
            register.alert(message, 'warning')
            continue
        conn_paths.append(conn_path)
    register.__set_conn_cfg(conn_paths)
#TODO

    scan_type = m_cache_json['testType']
    run_number = int(m_cache_json['runNumber'])
    target_charge = int(m_cache_json['targetCharge'])
    target_tot = int(m_cache_json['targetTot'])
    start_timestamp = int(m_cache_json['startTime'])
    command = m_cache_json['command']
    register.__set_test_run_start(scan_type, conn_paths, run_number, target_charge, target_tot, start_timestamp, command)

    register.__set_config(-1, -1, '{0}/{1}'.format(cache_dir, m_cache_json['configs']['ctrlCfg'][0]['path']), 'controller', 'ctrlCfg', 'testRun', 'null')

    if 'scanCfg' in m_cache_json['configs']: scan_cfg_path = '{0}/{1}'.format(cache_dir, m_cache_json['configs']['scanCfg'][0]['path'])
    else: scan_cfg_path = ''
    register.__set_config(-1, -1, scan_cfg_path, scan_type, 'scanCfg', 'testRun', 'null')

    for chip_json in m_cache_json['configs']['chipCfg']:
        chip_id = chip_json['_id']
        chip_path = '{0}/{1}'.format(cache_dir, chip_json['path'])
        filename  = chip_json['filename']
        title     = chip_json['title']
        register.__set_config(-1, -1, chip_path, filename, title, 'componentTestRun', chip_id)

    for attachment in m_cache_json['attachments']:
        chip_id = attachment['_id']
        file_path = '{0}/{1}'.format(cache_dir, attachment['path'])
        histoname = attachment['histoname']
        register.__set_attachment(-1, -1, file_path, histoname, chip_id)

    finish_timestamp = m_cache_json['finishTime']
    register.__set_test_run_finish(scan_type, conn_paths, run_number, target_charge, target_tot, finish_timestamp, command)

    return

def __write_dcs(cache_dir):
    if DB_DEBUG: print('Local DB: Write cache DCS data: {}'.format(cache_dir))

def cache():
    global args
    args = getArgs()

    db_url = 'mongodb://{0}:{1}'.format(args.host, args.port)
    db_name = args.database
    if not __init(db_url, db_name)==True:
        sys.exit()

    global m_cache_dir
    db_cache_path = m_cache_dir+'/var/cache/localdb'
    for file_name in os.listdir(db_cache_path):
        if not file_name.isdecimal(): continue
        cache_path = db_cache_path+'/'+file_name
        db_cfg_path = cache_path+'/database.json'
        __set_cache(cache_path)
#        __clear()

if __name__ == '__main__': cache()
